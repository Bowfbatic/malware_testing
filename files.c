/**
 * files.c contains all of the functionality for the download and upload commands.
 * @file files.c
 */

#include <files.h>
#include <stdio.h>
#include <stdlib.h>
#include <utils.h>
#include <string.h>
#include <arpa/inet.h>

uint32_t short_deserializer(char *bytes, u_int32_t *usign)
{
    // memcpy(usign, bytes, sizeof(u_int32_t));
    int i = 0;
    while (i < sizeof(u_int32_t))
    {
        ((char *)usign)[sizeof(u_int32_t) - 1 - i] = bytes[i];
        i++;
    }
    return sizeof(u_int32_t);
}

static uint32_t deserialize_upload_file_path(char *upload_args, char **file_path_out)
{
    uint32_t len;
    if (upload_args == NULL)
    {
        printf("upload_args is NULL\n");
        return 0;
    }

    upload_args += short_deserializer(upload_args, &len);

    *file_path_out = malloc(len + 1);
    if (*file_path_out == NULL)
    {
        return 0;
    }
    char *ptr = *file_path_out;

    memcpy(ptr, upload_args, len);
    ptr[len] = '\0';

    return len + sizeof(uint32_t);
}

static uint32_t deserialize_upload_file_contents(char *upload_args, char **contents_out)
{
    uint32_t len;
    if (upload_args == NULL)
    {
        printf("upload_args is NULL\n");
        exit(-1);
    }
    upload_args += short_deserializer(upload_args, &len);

    *contents_out = malloc(len + 1);
    if (*contents_out == NULL)
    {
        return 0;
    }
    char *ptr = *contents_out;
    memcpy(ptr, upload_args, len);
    ptr[len] = '\0';

    return len + sizeof(uint32_t);
}

/**
 * @brief opens file specified by parameter passed, puts the contents in contents_out and returns the size.
 * @param filename filename to open
 * @param contents_out a NULL pointer that will contain the contents of the file or NULL on error
 * @return an integer representing the number of bytes read
 */
uint32_t read_file(char *filename, char **contents_out)
{
    // Open the file in read binary mode
    FILE *fp = fopen(filename, "rb");

    // Check if file opened successfully
    if (fp == NULL)
    {
        return 0;
    }

    // Seek to the end of the file to get the file size
    fseek(fp, 0L, SEEK_END);
    long size = ftell(fp);
    rewind(fp); // Rewind to the beginning for reading

    // Check for empty file
    if (size == 0)
    {
        fclose(fp);
        return 0;
    }

    // Allocate memory to store file contents (plus null terminator)
    *contents_out = malloc(size + 1);
    if (*contents_out == NULL)
    {
        fclose(fp);
        return 0;
    }

    // Read the entire file contents into allocated memory
    uint32_t bytes_read = fread(*contents_out, 1, size, fp);

    // Check for reading errors
    if (bytes_read != size)
    {
        free(*contents_out);
        *contents_out = NULL;
        fclose(fp);
        return 0;
    }

    // Add null terminator at the end for string functionality
    (*contents_out)[size] = '\0';

    // Close the file
    fclose(fp);

    // Return the number of bytes read
    return bytes_read;
}

/**
 * @brief Write the contents of a stream to a specified file.
 * @param filename the name of the file to write to
 * @param contents a pointer to the contents that will be written
 * @param contents_size the size of the contents
 * @return returns the number of bytes written to the file
 */
uint32_t write_file(char *filename, char *contents, uint32_t contents_size)
{
    if (contents == NULL)
    {
        return 0;
    }

    uint32_t write_counter = 0;

    FILE *fp = fopen(filename, "wb");

    if (fp == NULL)
    {
        return 0;
    }

    write_counter = fwrite(contents, 1, contents_size, fp);

    fclose(fp);

    if (write_counter != contents_size)
    {
        return 0;
    }

    return write_counter;
}

/**
 * @brief Download the file specified in the Command args.
 * @param cmd the download command with arguments
 * @return a Response where the message is the file byte stream
 */
Response *download_file_command(Command *cmd)
{
    Response *rsp = NULL;

    if (cmd == NULL)
    {
        goto error_cmd;
    }

    if (cmd->args == NULL)
    {
        goto error_cmd;
    }

    FILE *fp = fopen(cmd->args, "rb");

    if (fp == NULL)
    {
        goto error_cmd;
    }

    fseek(fp, 0, SEEK_END);
    u_int32_t size = ftell(fp);
    rewind(fp);

    char *contents = malloc(size);
    if (contents == NULL)
    {
        free(contents);
        goto error_cmd;
    }

    uint32_t bytes_read = fread(contents, 1, size, fp);

    if (bytes_read != size)
    {
        goto error_cmd;
    }

    rsp = alloc_response(0, contents, size);
    free(contents);
    fclose(fp);
    goto end;

error_cmd:
    char *error_msg = "error downloading file";
    rsp = alloc_response(1, error_msg, strlen(error_msg));

end:
    return rsp;
}

/**
 * @brief deserialize the file path and file path length from upload arguments.
 * @param upload_args the full upload arguments passed in the command structure
 * @param file_path_out a NULL pointer that will contain the file path on success or NULL on error
 * @return the length of the file path
 */
// static uint32_t deserialize_upload_file_path(char *upload_args, char **file_path_out)
// {
//     uint32_t file_path_len;
//     // refer to the README.md to inform how to deserialize just the upload path
//     return file_path_len;
// }

/**
 * @brief deserialize the file contents and contents length from upload arguments.
 * @param upload_args the full upload arguments passed in the command structure
 * @param file_path_len length of the already deserialize file path
 * @param contents_out a NULL pointer that will contain the file contents on success or NULL on error
 * @return the length of the file path
 */
// static uint32_t deserialize_upload_file_contents(char *upload_args, uint32_t file_path_len, char **contents_out)
// {
//     uint32_t content_len;
//     // refer to the README.md to inform how to deserialize just the file contents
//     return content_len;
// }

/**
 * @brief Upload the file specified in the command arguments.
 * @param cmd the command structure
 * @return a response indicating upload success or failure
 */
Response *upload_file_command(Command *cmd)
{
    Response *rsp = NULL;

    if (cmd == NULL)
    {
        return NULL;
    }

    if (cmd->args_len == 0)
    {
        return NULL;
    }

    // deserialize command args
    uint32_t file_len = 0;
    char *filepath = NULL;
    char *args = cmd->args;
    args += deserialize_upload_file_path(cmd->args, &filepath);
    file_len = strlen(filepath);
    if (file_len < 1){
        free(filepath);
        char *error_msg = "error with upload file path\0";
        rsp = alloc_response(1, error_msg, strlen(error_msg));
        return rsp;
    }
    
    char *contents = NULL;
    uint32_t content_len = 0;
    deserialize_upload_file_contents(args, &contents);
    content_len = strlen(contents);
    if (content_len < 1){
        free (contents);
        char *error_msg = "error with upload file contents\0";
        rsp = alloc_response(1, error_msg, strlen(error_msg));
        return rsp;
    }

    uint32_t size = write_file(filepath, contents, content_len);
    char *msg = "upload successful\0";
    rsp = alloc_response(0, msg, strlen(msg));
    free(filepath);
    free(contents);
    return rsp;
}