/**
 * commands.c contains all of the functionality for serializeing and deserializing commands and responses.
 * @file commands.c
 */

#include "commands.h"
#include <arpa/inet.h>
#include <stdlib.h>
#include <stdbool.h>
#include <utils.h>

int byte_array_deserializer(char *bytes, int len, char *dest)
{
    // no need to fix endianness for singular bytes
    memcpy(dest, bytes, len);
    return len;
}

int u32_deserializer(char *bytes, u_int32_t *usign)
{
    // memcpy(usign, bytes, sizeof(u_int32_t));
    int i = 0;
    while (i < sizeof(u_int32_t))
    {
        ((char *)usign)[sizeof(u_int32_t) - 1 - i] = bytes[i];
        i++;
    }
    return sizeof(u_int32_t);
}

int serialize_short(u_int32_t iData, char *pTargetBuffer)
{
    // printf("%x\n", iData);
    u_int32_t iConverted = htonl(iData);
    // printf("%x\n", &iConverted);
    memcpy(pTargetBuffer, &iConverted, sizeof(u_int32_t));
    // printf("%x\n", pTargetBuffer);
    return sizeof(u_int32_t);
}

int serialize_byte(char *pData, char *pTargetBuffer, u_int32_t uiSize)
{
    memcpy(pTargetBuffer, pData, uiSize);
    return uiSize;
}

/**
 * @brief Deserialize a message stream of bytes into a Command structure.
 * @param msg_size (in) the total message stream size
 * @param msg_stream (in) a pointer to the message stream
 * @return a pointer to a Command structure or NULL on error
 */
Command *deserialize_command(uint32_t msg_size, char *msg_stream)
{

    // convert from network to host byte order
    uint32_t iConverted = ntohl(msg_size);

    // Validate command received (check msg_size and the total size given in the stream)
    uint32_t total_size = 0;
    msg_stream += u32_deserializer(msg_stream, &total_size);
    if (total_size != msg_size)
    {
        printf("Deserializing size did not match given size of command\n");
        return NULL;
    }

    // Get bytes ??

    // store command in struct,
    // {uint32:total_message_size}{uint32:command_length}{char[command_length]:command}{uint32:args_length}{char[args_length]:args}
    u_int32_t comm_len = 0;
    msg_stream += u32_deserializer(msg_stream, &comm_len);
    char *comm = malloc(comm_len * sizeof(char));
    msg_stream += byte_array_deserializer(msg_stream, comm_len, comm);

    u_int32_t args_len = 0;
    msg_stream += u32_deserializer(msg_stream, &args_len);
    char *args = malloc(args_len * sizeof(char));
    msg_stream += byte_array_deserializer(msg_stream, args_len, args);

    Command *cmd = alloc_command(comm, comm_len, args, args_len);
    return cmd;
}

/**
 * @brief Allocate the memory and store data in a new Command structure.
 * @param cmd (in) pointer to the cmd bytes
 * @param cmd_len (in) the size of the cmd
 * @param args (in) pointer to the args bytes
 * @param args_len (in) the size of the args
 * @return a pointer to an empty Command structure or NULL on error
 */
Command *alloc_command(char *cmd, uint32_t cmd_len, char *args, uint32_t args_len)
{
    Command *new_cmd = calloc(1, sizeof(Command));
    // if we get a null then there are memory issues and we need to bail
    if (new_cmd == NULL)
    {
        return new_cmd;
    }
    new_cmd->cmd = calloc(cmd_len, sizeof(char));
    memcpy(new_cmd->cmd, cmd, cmd_len);
    new_cmd->cmd_len = cmd_len;
    new_cmd->args = calloc(args_len, sizeof(char));
    memcpy(new_cmd->args, args, args_len);
    new_cmd->args_len = args_len;
    return new_cmd;
}

/**
 * @brief Free a Command structure and its components.
 * @param cmd a pointer to a Command structure
 */
void free_command(Command *cmd)
{
    if (cmd != NULL)
    {
        checkfree(cmd->cmd)
            checkfree(cmd->args)
                free(cmd);
    }
}

/**
 * @brief Serialize a Response structure into a byte stream.
 * @param rsp (in) a pointer to a Response structure
 * @param stream_out (out) a NULL char pointer where the stream will be passed back out
 * @return the total size of the stream
 */
uint32_t serialize_response(Response *rsp, char **stream_out)
{
    // initialize variables                                            /////////work on dis
    uint32_t total_size = rsp->msg_len + sizeof(rsp->msg_len) + sizeof(rsp->ret_code);
    *stream_out = malloc(total_size + sizeof(u_int32_t));
    if (*stream_out == NULL)
    {
        printf("Malloc Error\n");
        exit(-1);
    }
    char *ptr = *stream_out;

    ptr += serialize_short(total_size, ptr);

    ptr += serialize_short(rsp->ret_code, ptr);
    ptr += serialize_short(rsp->msg_len, ptr);
    memcpy(ptr, rsp->msg, rsp->msg_len);

    return total_size;
}

/**
 * @brief Allocate memory for a Response structure.
 * @param ret_code (in) the integer return code
 * @param msg (in) the message stream
 * @param msg_len (in) the size of the message stream
 * @return a pointer to a Response structure or NULL on error
 */
Response *alloc_response(int32_t ret_code, char *msg, uint32_t msg_len)
{
    Response *rsp;
    rsp = calloc(1, sizeof(Response));

    // if we get a null then there are memory issues and we need to bail
    if (rsp == NULL)
    {
        return rsp;
    }

    rsp->ret_code = ret_code;
    rsp->msg_len = msg_len;

    // need to include the null terminator
    rsp->msg = calloc(msg_len, sizeof(char));
    memcpy(rsp->msg, msg, msg_len);

    return rsp;
}

/**
 * @brief free a Response structure and its components.
 * @param rsp pointer to a Response structure
 */
void free_response(Response *rsp)
{

    // check to see if the Response structure is NULL
    if (rsp != NULL)
    {
        // free the message stream
        checkfree(rsp->msg)
            // free the whole structure
            free(rsp);
    }
}
